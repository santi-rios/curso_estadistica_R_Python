{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"ANOVA de Una Vía en Python\"\n",
        "author: \"Traducido y adaptado de R por un asistente de IA\"\n",
        "format: live-html\n",
        "pyodide: \n",
        "    packages: \n",
        "        - numpy\n",
        "        - pandas\n",
        "        - matplotlib\n",
        "        - seaborn\n",
        "        - pingouin\n",
        "        - statsmodels\n",
        "---\n",
        "\n",
        "## ¿Qué es el ANOVA de Una Vía?\n",
        "\n",
        "El **Análisis de Varianza de una vía** (One-way ANOVA) es una extensión de la prueba t independiente para comparar medias cuando tenemos **tres o más grupos**. Es la versión paramétrica del test de Kruskal-Wallis.\n",
        "\n",
        "### Características del ANOVA\n",
        "\n",
        "- **Compara medias**: Evalúa si las medias de varios grupos son estadísticamente diferentes\n",
        "- **Un solo factor**: Analiza el efecto de una sola variable independiente (factor)\n",
        "- **Múltiples grupos**: Funciona con 3 o más grupos (con 2 grupos es equivalente a t-test)\n",
        "\n",
        "### Principio del ANOVA\n",
        "\n",
        "El ANOVA compara dos tipos de variabilidad:\n",
        "1. **Variabilidad entre grupos**: ¿Qué tan diferentes son las medias de los grupos?\n",
        "2. **Variabilidad dentro de grupos**: ¿Qué tan variables son los datos dentro de cada grupo?\n",
        "\n",
        "Si la variabilidad entre grupos es mucho mayor que la variabilidad dentro de grupos, concluimos que hay diferencias significativas.\n",
        "\n",
        "## Hipótesis del ANOVA\n",
        "\n",
        "- **H₀**: Todas las medias poblacionales son iguales (μ₁ = μ₂ = μ₃ = ... = μₖ)\n",
        "- **H₁**: Al menos una media poblacional es diferente\n",
        "\n",
        "## Supuestos del ANOVA\n",
        "\n",
        "1. **Independencia**: Las observaciones deben ser independientes\n",
        "2. **Normalidad**: Los datos deben seguir una distribución normal en cada grupo\n",
        "3. **Homogeneidad de varianzas**: Las varianzas deben ser iguales entre grupos (homocedasticidad)\n",
        "\n",
        "## Ejemplo Práctico: Crecimiento de Plantas\n",
        "\n",
        "Usaremos un conjunto de datos sobre el crecimiento de plantas bajo diferentes tratamientos (control, tratamiento 1, tratamiento 2).\n",
        "\n",
        "### 1. Cargar librerías y datos\n",
        "\n",
        "```{pyodide}\n",
        "#| echo: false\n",
        "#| output: false\n",
        "import micropip\n",
        "await micropip.install(['pandas', 'numpy', 'scipy', 'seaborn', 'matplotlib', 'pingouin', 'statsmodels'])\n",
        "```\n",
        "\n",
        "```{pyodide}\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import scipy.stats as stats\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "import pingouin as pg\n",
        "from scipy.stats import f_oneway\n",
        "from statsmodels.stats.multicomp import pairwise_tukeyhsd\n",
        "import statsmodels.api as sm\n",
        "from statsmodels.formula.api import ols\n",
        "\n",
        "# Crear datos similares al dataset PlantGrowth de R\n",
        "np.random.seed(123)\n",
        "\n",
        "# Simular datos de crecimiento de plantas\n",
        "ctrl = np.random.normal(5.0, 0.6, 10)      # Grupo control\n",
        "trt1 = np.random.normal(4.7, 0.8, 10)      # Tratamiento 1\n",
        "trt2 = np.random.normal(5.5, 0.4, 10)      # Tratamiento 2\n",
        "\n",
        "# Crear DataFrame\n",
        "my_data = pd.DataFrame({\n",
        "    'weight': np.concatenate([ctrl, trt1, trt2]),\n",
        "    'group': ['ctrl'] * 10 + ['trt1'] * 10 + ['trt2'] * 10\n",
        "})\n",
        "\n",
        "# Convertir group a categórica con orden específico\n",
        "my_data['group'] = pd.Categorical(my_data['group'], \n",
        "                                 categories=['ctrl', 'trt1', 'trt2'], \n",
        "                                 ordered=True)\n",
        "\n",
        "print(\"Dataset de crecimiento de plantas:\")\n",
        "print(my_data.head(10))\n",
        "print(f\"\\nEstructura del dataset:\")\n",
        "print(f\"Total de observaciones: {len(my_data)}\")\n",
        "print(f\"Grupos: {my_data['group'].cat.categories.tolist()}\")\n",
        "print(f\"Observaciones por grupo: {my_data['group'].value_counts().sort_index()}\")\n",
        "```\n",
        "\n",
        "### 2. Exploración de Datos\n",
        "\n",
        "```{pyodide}\n",
        "# Estadísticas descriptivas por grupo\n",
        "estadisticas = my_data.groupby('group')['weight'].agg([\n",
        "    ('count', 'count'),\n",
        "    ('media', 'mean'),\n",
        "    ('desv_std', 'std'),\n",
        "    ('min', 'min'),\n",
        "    ('max', 'max')\n",
        "]).round(4)\n",
        "\n",
        "print(\"Estadísticas descriptivas por grupo:\")\n",
        "print(estadisticas)\n",
        "```\n",
        "\n",
        "### 3. Visualización de los Datos\n",
        "\n",
        "```{pyodide}\n",
        "# Crear múltiples visualizaciones\n",
        "fig, axes = plt.subplots(2, 2, figsize=(12, 10))\n",
        "\n",
        "# Boxplot\n",
        "sns.boxplot(x='group', y='weight', data=my_data, \n",
        "            palette=['#00AFBB', '#E7B800', '#FC4E07'], ax=axes[0,0])\n",
        "axes[0,0].set_title('Distribución por Grupo (Boxplot)')\n",
        "axes[0,0].set_xlabel('Tratamiento')\n",
        "axes[0,0].set_ylabel('Peso')\n",
        "\n",
        "# Violin plot\n",
        "sns.violinplot(x='group', y='weight', data=my_data, \n",
        "               palette=['#00AFBB', '#E7B800', '#FC4E07'], ax=axes[0,1])\n",
        "axes[0,1].set_title('Distribución por Grupo (Violin Plot)')\n",
        "axes[0,1].set_xlabel('Tratamiento')\n",
        "axes[0,1].set_ylabel('Peso')\n",
        "\n",
        "# Stripplot (puntos individuales)\n",
        "sns.stripplot(x='group', y='weight', data=my_data, \n",
        "              palette=['#00AFBB', '#E7B800', '#FC4E07'], \n",
        "              size=8, jitter=True, ax=axes[1,0])\n",
        "axes[1,0].set_title('Datos Individuales')\n",
        "axes[1,0].set_xlabel('Tratamiento')\n",
        "axes[1,0].set_ylabel('Peso')\n",
        "\n",
        "# Gráfico de medias con error estándar\n",
        "medias = my_data.groupby('group')['weight'].agg(['mean', 'sem'])\n",
        "x_pos = range(len(medias))\n",
        "axes[1,1].errorbar(x_pos, medias['mean'], yerr=medias['sem'], \n",
        "                   fmt='o', capsize=5, capthick=2, markersize=8,\n",
        "                   color=['#00AFBB', '#E7B800', '#FC4E07'])\n",
        "axes[1,1].set_xticks(x_pos)\n",
        "axes[1,1].set_xticklabels(medias.index)\n",
        "axes[1,1].set_title('Medias con Error Estándar')\n",
        "axes[1,1].set_xlabel('Tratamiento')\n",
        "axes[1,1].set_ylabel('Peso Promedio')\n",
        "axes[1,1].grid(True, alpha=0.3)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "### 4. Verificación de Supuestos\n",
        "\n",
        "#### 4.1 Prueba de Normalidad\n",
        "\n",
        "```{pyodide}\n",
        "print(\"Verificación de Supuestos del ANOVA\")\n",
        "print(\"=\"*50)\n",
        "print(\"\\n1. NORMALIDAD (Prueba de Shapiro-Wilk):\")\n",
        "print(\"H₀: Los datos siguen una distribución normal\")\n",
        "print(\"H₁: Los datos no siguen una distribución normal\\n\")\n",
        "\n",
        "normalidad_ok = True\n",
        "for grupo in my_data['group'].cat.categories:\n",
        "    grupo_data = my_data[my_data['group'] == grupo]['weight']\n",
        "    stat, p_value = stats.shapiro(grupo_data)\n",
        "    es_normal = p_value > 0.05\n",
        "    if not es_normal:\n",
        "        normalidad_ok = False\n",
        "    \n",
        "    print(f\"Grupo {grupo}:\")\n",
        "    print(f\"  Estadístico W: {stat:.4f}\")\n",
        "    print(f\"  p-valor: {p_value:.4f}\")\n",
        "    print(f\"  {'✓ Normal' if es_normal else '✗ No normal'} (α = 0.05)\\n\")\n",
        "\n",
        "print(f\"Supuesto de normalidad: {'✓ CUMPLIDO' if normalidad_ok else '✗ VIOLADO'}\")\n",
        "```\n",
        "\n",
        "#### 4.2 Prueba de Homogeneidad de Varianzas\n",
        "\n",
        "```{pyodide}\n",
        "print(\"\\n2. HOMOGENEIDAD DE VARIANZAS (Prueba de Levene):\")\n",
        "print(\"H₀: Las varianzas son iguales en todos los grupos\")\n",
        "print(\"H₁: Al menos una varianza es diferente\\n\")\n",
        "\n",
        "# Separar datos por grupo\n",
        "grupos = [my_data[my_data['group'] == grupo]['weight'] \n",
        "          for grupo in my_data['group'].cat.categories]\n",
        "\n",
        "# Prueba de Levene\n",
        "stat_levene, p_levene = stats.levene(*grupos)\n",
        "homogeneidad_ok = p_levene > 0.05\n",
        "\n",
        "print(f\"Estadístico de Levene: {stat_levene:.4f}\")\n",
        "print(f\"p-valor: {p_levene:.4f}\")\n",
        "print(f\"{'✓ Varianzas homogéneas' if homogeneidad_ok else '✗ Varianzas heterogéneas'} (α = 0.05)\")\n",
        "\n",
        "print(f\"\\nSupuesto de homogeneidad: {'✓ CUMPLIDO' if homogeneidad_ok else '✗ VIOLADO'}\")\n",
        "```\n",
        "\n",
        "#### 4.3 Gráficos de Diagnóstico\n",
        "\n",
        "```{pyodide}\n",
        "# Realizar ANOVA preliminar para obtener residuales\n",
        "model = ols('weight ~ C(group)', data=my_data).fit()\n",
        "residuales = model.resid\n",
        "valores_ajustados = model.fittedvalues\n",
        "\n",
        "# Gráficos de diagnóstico\n",
        "fig, axes = plt.subplots(1, 2, figsize=(12, 5))\n",
        "\n",
        "# Q-Q plot para normalidad de residuales\n",
        "stats.probplot(residuales, dist=\"norm\", plot=axes[0])\n",
        "axes[0].set_title('Q-Q Plot de Residuales')\n",
        "axes[0].grid(True, alpha=0.3)\n",
        "\n",
        "# Residuales vs valores ajustados (homogeneidad)\n",
        "axes[1].scatter(valores_ajustados, residuales, alpha=0.7)\n",
        "axes[1].axhline(y=0, color='red', linestyle='--')\n",
        "axes[1].set_xlabel('Valores Ajustados')\n",
        "axes[1].set_ylabel('Residuales')\n",
        "axes[1].set_title('Residuales vs Valores Ajustados')\n",
        "axes[1].grid(True, alpha=0.3)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "### 5. ANOVA de Una Vía\n",
        "\n",
        "```{pyodide}\n",
        "print(\"\\nANOVA DE UNA VÍA\")\n",
        "print(\"=\"*40)\n",
        "\n",
        "# Método 1: scipy.stats.f_oneway\n",
        "f_stat, p_value = f_oneway(*grupos)\n",
        "\n",
        "print(\"Resultados del ANOVA:\")\n",
        "print(f\"Estadístico F: {f_stat:.4f}\")\n",
        "print(f\"p-valor: {p_value:.4f}\")\n",
        "print(f\"Grados de libertad: {len(grupos)-1}, {len(my_data)-len(grupos)}\")\n",
        "\n",
        "# Método 2: usando statsmodels para tabla completa\n",
        "model = ols('weight ~ C(group)', data=my_data).fit()\n",
        "anova_table = sm.stats.anova_lm(model, typ=2)\n",
        "print(f\"\\nTabla ANOVA completa:\")\n",
        "print(anova_table)\n",
        "```\n",
        "\n",
        "### 6. Interpretación de Resultados\n",
        "\n",
        "```{pyodide}\n",
        "alpha = 0.05\n",
        "print(f\"\\nINTERPRETACIÓN DE RESULTADOS:\")\n",
        "print(\"=\"*40)\n",
        "\n",
        "if p_value < alpha:\n",
        "    print(f\"✓ SIGNIFICATIVO:\")\n",
        "    print(f\"p-valor ({p_value:.4f}) < α ({alpha})\")\n",
        "    print(\"Rechazamos H₀: Hay evidencia significativa de diferencias entre grupos.\")\n",
        "    print(\"Al menos una media es significativamente diferente de las otras.\")\n",
        "    hacer_posthoc = True\n",
        "else:\n",
        "    print(f\"✗ NO SIGNIFICATIVO:\")\n",
        "    print(f\"p-valor ({p_value:.4f}) ≥ α ({alpha})\")\n",
        "    print(\"No rechazamos H₀: No hay evidencia suficiente de diferencias entre grupos.\")\n",
        "    print(\"Las medias no son significativamente diferentes.\")\n",
        "    hacer_posthoc = False\n",
        "\n",
        "# Calcular tamaño del efecto (eta cuadrado)\n",
        "ss_between = anova_table['sum_sq'][0]\n",
        "ss_total = anova_table['sum_sq'].sum()\n",
        "eta_squared = ss_between / ss_total\n",
        "\n",
        "print(f\"\\nTamaño del efecto (η²): {eta_squared:.4f}\")\n",
        "if eta_squared < 0.01:\n",
        "    interpretacion_eta = \"efecto muy pequeño\"\n",
        "elif eta_squared < 0.06:\n",
        "    interpretacion_eta = \"efecto pequeño\"\n",
        "elif eta_squared < 0.14:\n",
        "    interpretacion_eta = \"efecto mediano\"\n",
        "else:\n",
        "    interpretacion_eta = \"efecto grande\"\n",
        "\n",
        "print(f\"Interpretación: {interpretacion_eta}\")\n",
        "```\n",
        "\n",
        "### 7. Comparaciones Post-Hoc (si es necesario)\n",
        "\n",
        "```{pyodide}\n",
        "if hacer_posthoc:\n",
        "    print(f\"\\nCOMPARACIONES POST-HOC\")\n",
        "    print(\"=\"*40)\n",
        "    \n",
        "    # Prueba de Tukey HSD\n",
        "    print(\"Prueba de Tukey HSD:\")\n",
        "    tukey_result = pairwise_tukeyhsd(endog=my_data['weight'], \n",
        "                                    groups=my_data['group'], \n",
        "                                    alpha=0.05)\n",
        "    print(tukey_result)\n",
        "    \n",
        "    # Comparaciones por pares con t-test y corrección de Bonferroni\n",
        "    print(f\"\\nComparaciones por pares (t-test con corrección de Bonferroni):\")\n",
        "    from scipy.stats import ttest_ind\n",
        "    from itertools import combinations\n",
        "    \n",
        "    grupos_nombres = my_data['group'].cat.categories\n",
        "    grupos_datos = {nombre: my_data[my_data['group'] == nombre]['weight'] \n",
        "                   for nombre in grupos_nombres}\n",
        "    \n",
        "    comparaciones = list(combinations(grupos_nombres, 2))\n",
        "    n_comparaciones = len(comparaciones)\n",
        "    alpha_corregido = 0.05 / n_comparaciones\n",
        "    \n",
        "    print(f\"α corregido (Bonferroni): {alpha_corregido:.4f}\")\n",
        "    \n",
        "    for grupo1, grupo2 in comparaciones:\n",
        "        t_stat, p_val = ttest_ind(grupos_datos[grupo1], grupos_datos[grupo2])\n",
        "        significativo = p_val < alpha_corregido\n",
        "        \n",
        "        media1 = grupos_datos[grupo1].mean()\n",
        "        media2 = grupos_datos[grupo2].mean()\n",
        "        diferencia = media1 - media2\n",
        "        \n",
        "        print(f\"\\n{grupo1} vs {grupo2}:\")\n",
        "        print(f\"  Diferencia de medias: {diferencia:.4f}\")\n",
        "        print(f\"  t-statistic: {t_stat:.4f}\")\n",
        "        print(f\"  p-valor: {p_val:.4f}\")\n",
        "        print(f\"  {'✓ Significativo' if significativo else '✗ No significativo'}\")\n",
        "```\n",
        "\n",
        "### 8. Visualización Final con Resultados\n",
        "\n",
        "```{pyodide}\n",
        "# Gráfico final con resultados estadísticos\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\n",
        "\n",
        "# Boxplot con información del ANOVA\n",
        "sns.boxplot(x='group', y='weight', data=my_data, \n",
        "            palette=['#00AFBB', '#E7B800', '#FC4E07'], ax=ax1)\n",
        "sns.stripplot(x='group', y='weight', data=my_data, \n",
        "              color='black', alpha=0.6, ax=ax1)\n",
        "\n",
        "ax1.set_title(f'ANOVA Una Vía\\nF = {f_stat:.3f}, p = {p_value:.4f}')\n",
        "ax1.set_xlabel('Tratamiento')\n",
        "ax1.set_ylabel('Peso')\n",
        "\n",
        "# Agregar líneas horizontales para mostrar medias\n",
        "for i, grupo in enumerate(my_data['group'].cat.categories):\n",
        "    media = my_data[my_data['group'] == grupo]['weight'].mean()\n",
        "    ax1.hlines(media, i-0.4, i+0.4, colors='red', linestyles='--', linewidth=2)\n",
        "\n",
        "# Gráfico de medias con intervalos de confianza\n",
        "medias = my_data.groupby('group')['weight'].mean()\n",
        "errores = my_data.groupby('group')['weight'].sem() * 1.96  # 95% CI\n",
        "\n",
        "x_pos = range(len(medias))\n",
        "bars = ax2.bar(x_pos, medias, yerr=errores, capsize=5, \n",
        "               color=['#00AFBB', '#E7B800', '#FC4E07'], alpha=0.7,\n",
        "               error_kw={'elinewidth': 2, 'capthick': 2})\n",
        "\n",
        "ax2.set_xticks(x_pos)\n",
        "ax2.set_xticklabels(medias.index)\n",
        "ax2.set_title('Medias con Intervalos de Confianza (95%)')\n",
        "ax2.set_xlabel('Tratamiento')\n",
        "ax2.set_ylabel('Peso Promedio')\n",
        "\n",
        "# Agregar valores en las barras\n",
        "for i, (bar, media) in enumerate(zip(bars, medias)):\n",
        "    height = bar.get_height()\n",
        "    ax2.text(bar.get_x() + bar.get_width()/2., height + errores.iloc[i],\n",
        "             f'{media:.2f}', ha='center', va='bottom', fontweight='bold')\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "### 9. Comparación con Alternativa No Paramétrica\n",
        "\n",
        "```{pyodide}\n",
        "# Comparar con Kruskal-Wallis (alternativa no paramétrica)\n",
        "from scipy.stats import kruskal\n",
        "\n",
        "h_stat, p_kruskal = kruskal(*grupos)\n",
        "\n",
        "print(f\"\\nCOMPARACIÓN CON ALTERNATIVA NO PARAMÉTRICA:\")\n",
        "print(\"=\"*50)\n",
        "print(f\"ANOVA paramétrico:    F = {f_stat:.4f}, p = {p_value:.4f}\")\n",
        "print(f\"Kruskal-Wallis:       H = {h_stat:.4f}, p = {p_kruskal:.4f}\")\n",
        "\n",
        "if (p_value < 0.05) == (p_kruskal < 0.05):\n",
        "    print(\"✓ Ambos tests concuerdan en la conclusión\")\n",
        "else:\n",
        "    print(\"⚠ Los tests difieren - revisar supuestos del ANOVA\")\n",
        "```\n",
        "\n",
        "## Cuándo Usar ANOVA vs Alternativas\n",
        "\n",
        "**Usa ANOVA cuando:**\n",
        "- Los supuestos se cumplen (normalidad y homogeneidad)\n",
        "- Quieres mayor poder estadístico\n",
        "- Los tamaños de muestra son adecuados\n",
        "\n",
        "**Usa Kruskal-Wallis cuando:**\n",
        "- Los supuestos del ANOVA se violan\n",
        "- Los datos son ordinales\n",
        "- Hay valores atípicos extremos\n",
        "\n",
        "**Usa transformaciones cuando:**\n",
        "- Los supuestos se violan ligeramente\n",
        "- La transformación mejora la normalidad/homogeneidad\n",
        "\n",
        "## Resumen de la Metodología\n",
        "\n",
        "1. **Exploración**: Estadísticas descriptivas y visualización\n",
        "2. **Verificación de supuestos**: Normalidad (Shapiro-Wilk) y homogeneidad (Levene)\n",
        "3. **ANOVA**: Calcular estadístico F y p-valor\n",
        "4. **Interpretación**: Decidir sobre H₀ y calcular tamaño del efecto\n",
        "5. **Post-hoc**: Si es significativo, identificar qué grupos difieren\n",
        "6. **Validación**: Comparar con alternativas no paramétricas si es necesario"
      ],
      "id": "1938a8ba"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/santi/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}