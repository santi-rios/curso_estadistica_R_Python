{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"ANOVA de Medidas Repetidas en Python\"\n",
        "author: \"Traducido y adaptado de R por un asistente de IA\"\n",
        "format: live-html\n",
        "pyodide: \n",
        "  packages: \n",
        "      - numpy\n",
        "      - pandas\n",
        "      - matplotlib\n",
        "      - seaborn\n",
        "      - statsmodels\n",
        "      - pingouin\n",
        "resources: \n",
        "    - datos\n",
        "---\n",
        "\n",
        "## ¿Qué es el ANOVA de Medidas Repetidas?\n",
        "\n",
        "El ANOVA de medidas repetidas se utiliza para analizar datos donde los mismos sujetos se miden más de una vez. Esta prueba también se conoce como ANOVA intra-sujetos. El término \"intra-sujetos\" significa que los mismos individuos son medidos en la misma variable de resultado bajo diferentes puntos de tiempo o condiciones.\n",
        "\n",
        "Por ejemplo, podrías haber medido la puntuación de autoestima (la variable de resultado) de 10 individuos en tres momentos durante un programa de intervención para determinar si su autoestima mejoró.\n",
        "\n",
        "### Tipos de ANOVA de Medidas Repetidas\n",
        "\n",
        "-   **ANOVA de una vía de medidas repetidas**: Una extensión de la prueba t de muestras pareadas para comparar las medias de tres o más niveles de una variable intra-sujetos (por ejemplo, tiempo).\n",
        "-   **ANOVA de dos vías de medidas repetidas**: Se utiliza para evaluar simultáneamente el efecto de dos factores intra-sujetos sobre una variable de resultado continua.\n",
        "\n",
        "## ANOVA de una vía de Medidas Repetidas en Python\n",
        "\n",
        "Vamos a realizar un ANOVA de una vía de medidas repetidas utilizando un conjunto de datos similar al de `selfesteem` de R.\n",
        "\n",
        "### 1. Cargar librerías y datos\n",
        "\n",
        "Primero, instalamos y cargamos las librerías necesarias.\n",
        "\n",
        "\n",
        "```{pyodide}\n",
        "import pandas as pd\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "```\n",
        "\n",
        "Usaremos `pingouin` para obtener un conjunto de datos de medidas repetidas.\n",
        "\n",
        "```{pyodide}\n",
        "# Cargamos los datos de medidas repetidas de pingouin\n",
        "data = pd.read_csv('./datos/rm_anova.csv')\n",
        "data.head()\n",
        "```\n",
        "\n",
        "Este conjunto de datos ya está en formato \"largo\", que es el adecuado para el análisis. Tenemos:\n",
        "- `Subject`: El identificador del sujeto.\n",
        "- `Time`: La variable intra-sujetos (por ejemplo, \"pre\", \"post\").\n",
        "- `Performance`: La variable dependiente o de resultado.\n",
        "\n",
        "### 2. Visualización de los datos\n",
        "\n",
        "Un gráfico de cajas o de puntos puede ayudar a visualizar los cambios a lo largo del tiempo.\n",
        "\n",
        "```{pyodide}\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.boxplot(x='Time', y='Performance', hue='Time', data=data, palette='viridis')\n",
        "plt.title('Rendimiento a lo largo del tiempo')\n",
        "plt.xlabel('Tiempo')\n",
        "plt.ylabel('Rendimiento')\n",
        "plt.show()\n",
        "\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.pointplot(x='Time', y='Performance', hue='Time', data=data, palette='viridis')\n",
        "plt.title('Rendimiento medio a lo largo del tiempo')\n",
        "plt.xlabel('Tiempo')\n",
        "plt.ylabel('Rendimiento Medio')\n",
        "plt.grid(True)\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "Los gráficos sugieren un aumento en el rendimiento a lo largo del tiempo.\n",
        "\n",
        "### 3. Realizar el ANOVA de Medidas Repetidas\n",
        "\n",
        "Usaremos la función `rm_anova()` de la librería `pingouin`. Necesitamos especificar:\n",
        "- `dv`: La variable dependiente (`Performance`).\n",
        "- `within`: La variable intra-sujetos (`Time`).\n",
        "- `subject`: El identificador del sujeto (`Subject`).\n",
        "\n",
        "```{pyodide}\n",
        "import pingouin as pg\n",
        "\n",
        "# Realizar el ANOVA de medidas repetidas\n",
        "res_aov = pg.rm_anova(data=data, dv='Performance', within='Time', subject='Subject')\n",
        "\n",
        "print(res_aov)\n",
        "```\n",
        "\n",
        "### 4. Interpretación de los resultados\n",
        "\n",
        "La tabla de resultados nos muestra:\n",
        "\n",
        "-   **Source**: La fuente de variación, en este caso, `Time`.\n",
        "-   **p-unc**: El valor p no corregido. En nuestro ejemplo, es muy bajo (`< 0.001`), lo que indica que hay un cambio estadísticamente significativo en el `Performance` a lo largo del `Time`.\n",
        "\n",
        "**Conclusión**: El tiempo tiene un efecto significativo en el rendimiento.\n",
        "\n",
        "### 5. Supuesto de Esfericidad\n",
        "\n",
        "El ANOVA de medidas repetidas tiene un supuesto adicional llamado **esfericidad**. Este supuesto se aplica cuando tienes 3 o más niveles en tu factor intra-sujetos y se refiere a que las varianzas de las diferencias entre todas las combinaciones de niveles son iguales.\n",
        "\n",
        "`pingouin` automáticamente realiza la **prueba de esfericidad de Mauchly**:\n",
        "\n",
        "-   **W**: El estadístico de la prueba.\n",
        "-   **p-val**: El valor p de la prueba de Mauchly.\n",
        "-   **sphericity**: Un booleano que indica si se cumple el supuesto (si `p-val` > 0.05).\n",
        "\n",
        "En nuestro resultado, `sphericity` es `True` y el `p-val` es `0.393`, lo que significa que se cumple el supuesto de esfericidad y podemos confiar en el valor p no corregido (`p-unc`).\n",
        "\n",
        "Si no se cumpliera la esfericidad (`sphericity` fuera `False`), deberíamos usar los valores p corregidos, como el de **Greenhouse-Geisser (`gg-corr`)** o el de **Huynh-Feldt (`hf-corr`)**. `pingouin` los proporciona en la misma tabla.\n",
        "\n",
        "### 6. Pruebas Post-Hoc\n",
        "\n",
        "Dado que el ANOVA nos dijo que hay una diferencia, pero no dónde, podemos realizar pruebas post-hoc (como comparaciones por pares con corrección de Bonferroni) para ver qué momentos son diferentes entre sí.\n",
        "\n",
        "```{pyodide}\n",
        "# Pruebas post-hoc por pares\n",
        "post_hocs = pg.pairwise_tests(data=data, dv='Performance', within='Time', subject='Subject', padjust='bonf')\n",
        "\n",
        "print(post_hocs)\n",
        "```\n",
        "\n",
        "La tabla de post-hoc nos muestra las comparaciones entre cada par de niveles de `Time`:\n",
        "- `Time A` vs `Time B`: Los niveles que se comparan.\n",
        "- `p-corr`: El valor p corregido.\n",
        "\n",
        "Todas las comparaciones (`pre` vs `post`, `pre` vs `fup`, `post` vs `fup`) tienen un `p-corr` muy bajo, lo que indica que el rendimiento fue significativamente diferente en todos los momentos medidos."
      ],
      "id": "e970183d"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/santi/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}